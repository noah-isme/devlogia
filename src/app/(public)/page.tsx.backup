import Link from "next/link";

import { Prisma } from "@prisma/client";

import { PersonalizedFeedSection } from "@/components/personalization/PersonalizedFeedSection";
import { Button, buttonVariants } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Pagination } from "@/components/ui/pagination";
import {
  appendToStack,
  clampLimit,
  encodeCursor,
  parseCursorParam,
  parseStackParam,
  serializeStack,
} from "@/lib/pagination";
import { estimateReadingTime, formatDate } from "@/lib/utils";

export const revalidate = 120;

const DEFAULT_POSTS_PER_PAGE = 10;
const MAX_POSTS_PER_PAGE = 25;

type HomePageProps = {
  searchParams?: Promise<Record<string, string | string[] | undefined>>;
};

type PublishedPost = Prisma.PostGetPayload<{
  include: { author: true; tags: { include: { tag: true } } };
}>;

export default async function HomePage({ searchParams }: HomePageProps) {
  // Unwrap searchParams Promise (Next.js 16+)
  const params = await searchParams;
  
  const searchQuery = typeof params?.q === "string" ? params.q.trim().slice(0, 200) : "";
  const tagParam = typeof params?.tag === "string" ? params.tag : "";
  const tagSlug = tagParam.toLowerCase().replace(/[^a-z0-9-]/g, "");
  const limit = clampLimit(params?.limit, DEFAULT_POSTS_PER_PAGE, {
    min: 3,
    max: MAX_POSTS_PER_PAGE,
  });

  const cursorParam = parseCursorParam(params?.cursor);
  const stack = parseStackParam(params?.stack);
  // TODO: Implement cursor-based pagination with MySQL-compatible queries

  const prismaModule = await import("@/lib/prisma");
  const { prisma, safeFindMany, isDatabaseEnabled } = prismaModule;

  if (!isDatabaseEnabled) {
    return (
      <section className="space-y-10">
        <header className="space-y-4">
          <h1 className="text-3xl font-semibold tracking-tight sm:text-4xl">
            Deep writing for curious developers
          </h1>
          <p className="max-w-2xl text-base text-muted-foreground">
            Devlogia combines MDX, autosave, and SEO-friendly defaults so you can share long-form insights without
            friction.
          </p>
        </header>
        <div className="rounded-xl border border-border/60 bg-primary/10 p-4 text-sm text-primary-foreground">
          Personalized recommendations powered by Devlogia AI.
        </div>
        <div className="rounded-md border border-dashed border-border bg-muted/40 p-6 text-sm text-muted-foreground">
          <p className="font-medium">Database connection unavailable</p>
          <p className="mt-2">
            Set the <code>DATABASE_URL</code> environment variable to connect Prisma and load published posts.
          </p>
        </div>
      </section>
    );
  }

  let posts: PublishedPost[] = [];
  let hasNext = false;
  let loadError: unknown | null = null;

  const tagsPromise = prisma.tag
    .findMany({
      where: { posts: { some: { post: { status: "PUBLISHED" } } } },
      select: { id: true, name: true, slug: true },
      orderBy: { name: "asc" },
    })
    .catch((error) => {
      console.error("Failed to load tags for search filters:", error);
      return [] as Array<{ id: string; name: string; slug: string }>;
    });

  try {
    // Build where clause using Prisma Query Builder (MySQL-compatible)
    type WhereClause = Prisma.PostWhereInput;
    const whereClause: WhereClause = {
      status: "PUBLISHED",
    };

    if (tagSlug) {
      whereClause.tags = {
        some: {
          tag: {
            slug: tagSlug,
          },
        },
      };
    }

    if (searchQuery) {
      // MySQL full-text search fallback to LIKE for now
      whereClause.OR = [
        { title: { contains: searchQuery } },
        { excerpt: { contains: searchQuery } },
        { body: { contains: searchQuery } },
      ];
    }

    // Use Prisma query builder instead of raw SQL
    const fetchedPosts = await safeFindMany<PublishedPost>("post", {
      where: whereClause,
      orderBy: [
        { publishedAt: "desc" },
        { createdAt: "desc" },
        { id: "desc" },
      ],
      take: limit + 1,
      include: { author: true, tags: { include: { tag: true } } },
    });

    hasNext = fetchedPosts.length > limit;
    posts = hasNext ? fetchedPosts.slice(0, limit) : fetchedPosts;
  } catch (error) {
    loadError = error;
    console.error("Failed to load published posts:", error);
  }

  if (loadError) {
    return (
      <section className="space-y-10">
        <header className="space-y-4">
          <h1 className="text-3xl font-semibold tracking-tight sm:text-4xl">
            Deep writing for curious developers
          </h1>
          <p className="max-w-2xl text-base text-muted-foreground">
            Devlogia combines MDX, autosave, and SEO-friendly defaults so you can share long-form insights without friction.
          </p>
        </header>
        <div className="rounded-xl border border-border/60 bg-primary/10 p-4 text-sm text-primary-foreground">
          Personalized recommendations powered by Devlogia AI.
        </div>
        <div className="rounded-md border border-dashed border-border bg-muted/40 p-6 text-sm text-muted-foreground">
          <p className="font-medium">Content unavailable</p>
          <p className="mt-2">
            We couldn&apos;t load published posts. Verify your database connection and try again.
          </p>
        </div>
      </section>
    );
  }

  const tags = await tagsPromise;
  const hasFilters = Boolean(searchQuery || tagSlug);
  const hasPrevious = stack.length > 0;

  const baseQuery: Record<string, string | undefined> = {
    q: searchQuery || undefined,
    tag: tagSlug || undefined,
    limit: limit !== DEFAULT_POSTS_PER_PAGE ? String(limit) : undefined,
  };

  const lastPost = posts.at(-1);
  const nextCursor =
    hasNext && lastPost
      ? encodeCursor({
          id: lastPost.id,
          sortKey: (lastPost.publishedAt ?? lastPost.createdAt).toISOString(),
        })
      : null;

  const nextStack = serializeStack(appendToStack(stack, cursorParam));
  const prevStack = serializeStack(stack.slice(0, -1));
  const prevCursor = stack.length ? stack[stack.length - 1] : null;

  const nextQuery = hasNext
    ? {
        ...baseQuery,
        cursor: nextCursor ?? undefined,
        stack: nextStack,
      }
    : undefined;

  const previousQuery = hasPrevious
    ? {
        ...baseQuery,
        cursor: prevCursor ?? undefined,
        stack: prevStack,
      }
    : undefined;

  return (
    <section className="space-y-10">
      <header className="space-y-4">
        <h1 className="text-3xl font-semibold tracking-tight sm:text-4xl">
          Deep writing for curious developers
        </h1>
        <p className="max-w-2xl text-base text-muted-foreground">
          Devlogia combines MDX, autosave, and SEO-friendly defaults so you can share long-form insights without friction.
        </p>
      </header>

      <div className="rounded-xl border border-border/60 bg-primary/10 p-4 text-sm text-primary-foreground">
        Personalized recommendations powered by Devlogia AI.
      </div>

      <PersonalizedFeedSection />

      <div className="space-y-6 rounded-lg border border-border bg-muted/30 p-4 sm:p-6">
        <form className="flex flex-col gap-3 sm:flex-row sm:items-center" action="/" method="GET">
          <Input
            type="search"
            name="q"
            placeholder="Search posts…"
            defaultValue={searchQuery}
            className="sm:flex-1"
          />
          {tagSlug ? <input type="hidden" name="tag" value={tagSlug} /> : null}
          {limit !== DEFAULT_POSTS_PER_PAGE ? <input type="hidden" name="limit" value={String(limit)} /> : null}
          <Button type="submit" className="sm:w-auto">
            Search
          </Button>
          {hasFilters ? (
            <Link href="/" className={buttonVariants({ variant: "ghost" })}>
              Reset
            </Link>
          ) : null}
        </form>

        {tags.length ? (
          <div className="flex flex-wrap items-center gap-2">
            <span className="text-xs uppercase tracking-wide text-muted-foreground">Tags</span>
            {tags.map((tag) => {
              const params = new URLSearchParams();
              if (searchQuery) {
                params.set("q", searchQuery);
              }
              if (limit !== DEFAULT_POSTS_PER_PAGE) {
                params.set("limit", String(limit));
              }
              params.set("tag", tag.slug);
              const href = `/?${params.toString()}`;
              const isActive = tagSlug === tag.slug;

              return (
                <Link
                  key={tag.id}
                  href={href}
                  className={`rounded-full border px-3 py-1 text-xs font-medium transition ${
                    isActive
                      ? "border-foreground bg-foreground text-background"
                      : "border-border bg-background text-muted-foreground hover:border-foreground/60 hover:text-foreground"
                  }`}
                  aria-current={isActive ? "page" : undefined}
                >
                  #{tag.name}
                </Link>
              );
            })}
            {tagSlug ? (
              <Link
                href={(() => {
                  const params = new URLSearchParams();
                  if (searchQuery) params.set("q", searchQuery);
                  if (limit !== DEFAULT_POSTS_PER_PAGE) params.set("limit", String(limit));
                  return params.size ? `/?${params.toString()}` : "/";
                })()}
                className="text-xs text-muted-foreground underline-offset-4 hover:underline"
              >
                Clear tag filter
              </Link>
            ) : null}
          </div>
        ) : null}
      </div>

      <div className="space-y-10">
        {posts.length === 0 ? (
          <p className="text-muted-foreground">
            {hasFilters
              ? `No posts found${searchQuery ? ` for “${searchQuery}”` : ""}${tagSlug ? ` with tag #${tagSlug}` : ""}.`
              : "No published posts yet. Check back soon."}
          </p>
        ) : (
          posts.map((post) => (
            <article key={post.id} className="space-y-3 border-b border-border pb-8 last:border-b-0 last:pb-0">
              <header className="space-y-2">
                <p className="text-sm text-muted-foreground">
                  {post.publishedAt ? formatDate(post.publishedAt) : "Draft"} · {estimateReadingTime(post.contentMdx)}
                </p>
                <h2 className="text-2xl font-semibold tracking-tight">
                  <Link href={`/blog/${post.slug}`} className="hover:underline">
                    {post.title}
                  </Link>
                </h2>
                {post.summary ? (
                  <p className="text-base text-muted-foreground">{post.summary}</p>
                ) : null}
              </header>
              {post.tags.length ? (
                <div className="flex flex-wrap gap-2">
                  {post.tags.map(({ tag }) => (
                    <span
                      key={tag.id}
                      className="rounded-full bg-muted px-3 py-1 text-xs font-medium text-muted-foreground"
                    >
                      #{tag.name}
                    </span>
                  ))}
                </div>
              ) : null}
            </article>
          ))
        )}
      </div>
      <Pagination
        basePath="/"
        hasNext={Boolean(hasNext)}
        hasPrevious={hasPrevious}
        nextQuery={nextQuery}
        previousQuery={previousQuery}
      />
    </section>
  );
}
